/*******************************************************************************
 * Name        : vxc_util.c
 * Author      : Your name
 * Copyright   : Your copyright notice
 * Description : Utility source file generated by VivanteIDE
 *******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include <math.h>
#define _BASETSD_H
#include "jpeglib.h"
#include "VX/vx_khr_cnn.h"
#include "vxc_nn_dynamic_fixed_point_8.h"
#include "vxc_util.h"
#include "vx_utility.h"

#ifndef ROUND_HALF_UP
#if defined(WIN32) && !defined(__MINGW32__)
vx_int32 rint_c(vx_float32 val)
{
                vx_float32 r0x,r0y,r0z;
                vx_int32 sign;
                r0y = fabsf(val) + 0.5f;
                r0y = floor(r0y);
                r0z = floor(fabsf(val));
                r0x = fabsf(val) - r0z;
                if(r0x == 0.5)
                {
                                vx_int32 R0x = r0y;
                                R0x = R0x & 1;
                                r0y = r0y - R0x;
                                sign = val > 0 ? 1 : (val < 0 ? -1 : 0);
                                r0y = r0y * sign;
                                return (vx_int32)r0y;
                }
                else
                {
                                sign = val > 0 ? 1 : (val < 0 ? -1 : 0);
                                r0y = r0y * sign;
                                return (vx_int32)r0y;
                }
}
#endif
vx_int8 Fp32toInt8(vx_float32 in, vx_int32 fl)
{
#if defined(WIN32) && !defined(__MINGW32__)
                vx_int32 data = (vx_int32)rint_c(in / pow (2.0, -fl));
#else
                vx_int32 data = (vx_int32)rint(in / pow (2, -fl));
#endif
    return (vx_int8)((data >  127) ? 127 : (data < -128) ? -128 : data);
}

vx_int16 Fp32toInt16(vx_float32 in, vx_int32 fl)
{
#if defined(WIN32) && !defined(__MINGW32__)
                vx_int32 data = (vx_int32)rint_c(in / pow (2.0, -fl));
#else
                vx_int32 data = (vx_int32)rint(in / pow (2, -fl));
#endif
    return (vx_int16)((data >  32767) ? 32767 : (data < -32768) ? -32768 : data);
}

vx_uint8 Fp32toUint8(vx_float32 in, vx_int32 zero_point, vx_float32 scale)
{
#if defined(WIN32) && !defined(__MINGW32__)
                vx_int32 data = (vx_int32)rint_c(in / scale);
#else
                vx_int32 data = (vx_int32)rint(in / scale);
#endif
                data += zero_point;
    return (vx_uint8)((data >  255) ? 255 : (data < 0) ? 0 : data);
}
#else
#if defined(WIN32) && !defined(__MINGW32__)
vx_float32 roundf(vx_float32 x)
{
#if defined(_M_X64)
        return (vx_float32) _copysignf(floorf(fabsf(x) + 0.5f), x);
#else
            return (vx_float32) _copysign(floorf(fabsf(x) + 0.5f), x);
#endif
}
#endif
vx_int8 Fp32toInt8(vx_float32 in, vx_int32 fl)
{
    vx_int32 data = (vx_int32)roundf(in / pow (2, -fl));
    return (vx_int8)((data >  127) ? 127 : (data < -128) ? -128 : data);
}

vx_int16 Fp32toInt16(vx_float32 in, vx_int32 fl)
{
    vx_int32 data = (vx_int32)roundf(in / pow (2, -fl));
    return (vx_int16)((data >  32767) ? 32767 : (data < -32768) ? -32768 : data);
}

Fp32toUint8(vx_float32 in, vx_int32 zero_point, vx_float32 scale)
{
    vx_int32 data = (vx_int32)roundf(in / scale);
    data += zero_point;
    return (vx_uint8)((data >  255) ? 255 : (data < 0) ? 0 : data);
}
#endif

vx_float32 Int8toFp32(vx_int8 val, vx_int8 fixedPointPos)
{
    vx_float32 result = 0.0f;

    if (fixedPointPos > 0)
    {
        result = (vx_float32)val * (1.0f / ((vx_float32) (1 << fixedPointPos)));
    }
    else
    {
        result = (vx_float32)val * ((vx_float32) (1 << -fixedPointPos));
    }

    return result;
}

vx_float32 Int16toFp32(vx_int16 val, vx_int8 fixedPointPos)
{
    vx_float32 result = 0.0f;

    if (fixedPointPos > 0)
    {
        result = (vx_float32)val * (1.0f / ((vx_float32) (1 << fixedPointPos)));
    }
    else
    {
        result = (vx_float32)val * ((vx_float32) (1 << -fixedPointPos));
    }

    return result;
}

vx_float32 Uint8toFp32(vx_uint8 val, vx_int32 zero_point, vx_float32 scale)
{
    vx_float32 result = 0.0f;

    result = ((vx_float32)val - zero_point) * scale;

    return result;
}

vx_float32 Fp16toFp32(const vx_int16 in)
{
    vx_int32 t1;
    vx_int32 t2;
    vx_int32 t3;
    vx_float32 out;

    t1 = in & 0x7fff;                       // Non-sign bits
    t2 = in & 0x8000;                       // Sign bit
    t3 = in & 0x7c00;                       // Exponent

    t1 <<= 13;                              // Align mantissa on MSB
    t2 <<= 16;                              // Shift sign bit into position

    t1 += 0x38000000;                       // Adjust bias

    t1 = (t3 == 0 ? 0 : t1);                // Denormals-as-zero

    t1 |= t2;                               // Re-insert sign bit

    *((uint32_t*)&out) = t1;

    return out;
}

vx_uint16 Fp32toFp16(vx_float32 in)
{
    vx_uint32 fp32 = *((vx_uint32 *) &in);
    vx_uint32 t1 = (fp32 & 0x80000000u) >> 16;  /* sign bit. */
    vx_uint32 t2 = (fp32 & 0x7F800000u) >> 13;  /* Exponent bits */
    vx_uint32 t3 = (fp32 & 0x007FE000u) >> 13;  /* Mantissa bits, no rounding */
    vx_uint32 fp16 = 0u;

    if (t2 >= 0x023c00u)
    {
        fp16 = t1 | 0x7BFF;     /* Don't round to infinity. */
    }
    else if (t2 <= 0x01c000u)
    {
        fp16 = t1;
    }
    else
    {
        t2 -= 0x01c000u;
        fp16 = t1 | t2 | t3;
    }

    return (vx_uint16) fp16;
}

int convertJpegToBmpData(FILE * inputFile, unsigned char* bmpData,
        uint32_t *bmpWidth, uint32_t *bmpHeight)
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPARRAY buffer;
    unsigned char *point = NULL;
    unsigned long width, height;
    unsigned short depth;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo,inputFile);
    jpeg_read_header(&cinfo,TRUE);

    if (bmpData == NULL)
    {
        width = cinfo.image_width;
        height = cinfo.image_height;
    }
    else
    {
        jpeg_start_decompress(&cinfo);

        width  = cinfo.output_width;
        height = cinfo.output_height;
        depth  = cinfo.output_components;


        buffer = (*cinfo.mem->alloc_sarray)
            ((j_common_ptr)&cinfo, JPOOL_IMAGE, width*depth, 1);

        point = bmpData;

        while (cinfo.output_scanline < height)
        {
            jpeg_read_scanlines(&cinfo, buffer, 1);
            memcpy(point, *buffer, width * depth);
            point += width * depth;
        }

        jpeg_finish_decompress(&cinfo);
    }

    jpeg_destroy_decompress(&cinfo);

    if (bmpWidth != NULL) *bmpWidth = width;
    if (bmpHeight != NULL) *bmpHeight = height;
    return depth;
}

void* prepareTensorData(char* name, vx_uint32 width, vx_uint32 height,
        vx_uint32 channels)
{
    int i = 0;
    float fval = 0.0;
#if defined(NN_TENSOR_DATA_FORMAT_INT8)
    vx_int8 *tensorData;
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
    vx_uint8 *tensorData;
#elif defined(NN_TENSOR_DATA_FORMAT_INT16)
    vx_int16 *tensorData;
#else
    vx_uint16 *tensorData;
#endif
    FILE *tensorFile;

    tensorFile = fopen(name, "rb");
    if (tensorFile == NULL) return NULL;

    tensorData = (typeof(tensorData)) malloc( width * height * channels * sizeof(*tensorData));
    if (tensorData == NULL) return NULL;
    memset(tensorData, 0, sizeof(*tensorData) * width * height * channels);

    for(i=0; i < width * height * channels; i++) {
        fscanf( tensorFile, "%f ", &fval );
#if defined(NN_TENSOR_DATA_FORMAT_INT8)
        tensorData[i] = Fp32toInt8(fval, NN_INPUT_FIXED_POINT_POS);
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
        tensorData[i] = Fp32toUint8(fval, NN_INPUT_AFFINE_ZERO_POINT, NN_INPUT_AFFINE_SCALE);
#elif defined(NN_TENSOR_DATA_FORMAT_INT16)
        tensorData[i] = Fp32toInt16(fval, NN_INPUT_FIXED_POINT_POS);
#else
        tensorData[i] = Fp32toFp16(fval);
#endif
    }
    fclose(tensorFile);
    return tensorData;
}

void* prepareImageData(char *name, vx_uint32 width, vx_uint32 height,
        vx_uint32 channels)
{
    vx_uint32 i, j, offset;
    vx_uint8 *bmpData;
    vx_float32 *preprocessData;
#if defined(NN_TENSOR_DATA_FORMAT_INT8)
    vx_int8 *outputData = NULL;
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
    vx_uint8 *outputData = NULL;
#elif defined(NN_TENSOR_DATA_FORMAT_INT16)
    vx_int16 *outputData = NULL;
#else
    vx_uint16 *outputData = NULL;
#endif
    FILE * bmpFile;

    bmpFile = fopen(name, "rb");
    if (bmpFile == NULL) return NULL;

    bmpData = (vx_uint8*) malloc(width * height * channels * sizeof(vx_uint8));
    if (bmpData == NULL) return NULL;
    memset(bmpData, 0, sizeof(vx_uint8) * width * height * channels);

    preprocessData = (vx_float32*)malloc(width * height * channels * sizeof(vx_float32));
    if (preprocessData == NULL) return NULL;
    memset(preprocessData, 0, sizeof(vx_float32) * width * height * channels);

    outputData = (typeof(outputData)) malloc(width * height * channels * sizeof(*outputData));
    if (outputData == NULL) return NULL;
    memset(outputData, 0, sizeof(*outputData) * width * height * channels);

    convertJpegToBmpData(bmpFile, bmpData, NULL, NULL);

    fclose(bmpFile);

    for (i = 0; i < channels; i++)
    {
        offset = width * height * (channels - 1 - i);

        for (j = 0; j < width * height; j++)
        {
#if defined(NN_TENSOR_DATA_FORMAT_INT8)
            preprocessData[j * channels + i] = (vx_float32)bmpData[j * channels + i] / 256;
            outputData[j + offset] = Fp32toInt8((vx_float32)preprocessData[j * channels + i], NN_INPUT_FIXED_POINT_POS);
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
            preprocessData[j * channels + i] = (vx_float32)bmpData[j * channels + i] / 256;
            outputData[j + offset] = Fp32toUint8((vx_float32)preprocessData[j * channels + i], NN_INPUT_AFFINE_ZERO_POINT, NN_INPUT_AFFINE_SCALE);
#elif defined(NN_TENSOR_DATA_FORMAT_INT16)
            preprocessData[j * channels + i] = (vx_float32)bmpData[j * channels + i] / 256;
            outputData[j + offset] = Fp32toInt16((vx_float32)preprocessData[j * channels + i], NN_INPUT_FIXED_POINT_POS);
#else
            preprocessData[j * channels + i] = (vx_float32)bmpData[j * channels + i] / 256;
            outputData[j + offset] = Fp32toFp16((vx_float32)preprocessData[j * channels + i]);
#endif
        }
    }
    free(preprocessData);
    free(bmpData);
    return outputData;
}

void* prepareData(char *name, int n, int format)
{
    FILE * f = NULL;
    void *data = NULL;
    float val;
    int i;

    f = fopen(name, "rb");
    if (f == NULL) return NULL;

    data = calloc(n, vxcGetTypeSize(format));
    if (data == NULL) goto error;

    if (format == VX_TYPE_FLOAT16) {
        vx_uint16 *element = (vx_uint16*)data;

        for (i = 0;i < n; i++) {
            fscanf(f, "%f\n", &val);
            *(element++) = Fp32toFp16(val);
        }
    }
#if defined(NN_TENSOR_DATA_FORMAT_INT8)
    else if (format == VX_TYPE_INT8) {
        vx_int8 *element = (vx_int8*)data;

        for (i = 0;i < n; i++) {
            fscanf(f, "%f\n", &val);
            *(element++) = Fp32toInt8(val, NN_INPUT_FIXED_POINT_POS);
        }
    }
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
    else if (format == VX_TYPE_UINT8) {
        vx_uint8 *element = (vx_uint8*)data;

        for (i = 0;i < n; i++) {
            fscanf(f, "%f\n", &val);
            *(element++) = Fp32toUint8(val, NN_INPUT_AFFINE_ZERO_POINT, NN_INPUT_AFFINE_SCALE);
        }
    }
#elif defined(NN_TENSOR_DATA_FORMAT_INT16)
    else if (format == VX_TYPE_INT16) {
        vx_int16 *element = (vx_int16*)data;

        for (i = 0;i < n; i++) {
            fscanf(f, "%f\n", &val);
            *(element++) = Fp32toInt16(val, NN_INPUT_FIXED_POINT_POS);
        }
    }
#endif
    else {
        goto error;
    }

    fclose(f);
    return data;

error:
    if (data)
        free(data);

    if (f)
        fclose(f);

    return NULL;
}

#define MAX_TOP_NUM 20

vx_bool getTop(vx_float32 *pfProb, vx_float32 *pfMaxProb, vx_uint32 *pMaxClass,
        vx_uint32 outputCount, vx_uint32 topNum)
{
    vx_uint32 i, j;

    if (topNum > MAX_TOP_NUM) return vx_false_e;

    memset(pfMaxProb, 0, sizeof(vx_float32) * topNum);
    memset(pMaxClass, 0xff, sizeof(vx_float32) * topNum);

    for (j = 0; j < topNum; j++)
    {
        for (i=0; i<outputCount; i++)
        {
            if ((i == *(pMaxClass+0)) || (i == *(pMaxClass+1)) || (i == *(pMaxClass+2)) ||
                    (i == *(pMaxClass+3)) || (i == *(pMaxClass+4)))
                continue;

            if (pfProb[i] > *(pfMaxProb+j))
            {
                *(pfMaxProb+j) = pfProb[i];
                *(pMaxClass+j) = i;
            }
        }
    }

    return vx_true_e;
}

vx_float32 * showResult(void* buffer, vx_uint32 count,int num, vx_uint32 num_of_dims,
        vx_uint32 *output_size, vx_enum data_type, vx_enum quant_format,
        vx_uint8 fix_pos, vx_int32 zero_point, vx_float32 scale, int size)
{
    vx_uint32 i;
    vx_uint32 MaxClass[5];
    vx_float32 fMaxProb[5];
    vx_float32 *outBuf;
    FILE *fp=NULL;
    char filename[200];

    memset(filename,0,sizeof(filename));
    if(num_of_dims == 4)
       sprintf(filename, "output_%d_%dx%dx%dx%d.tensor",num,output_size[0],output_size[1],output_size[2],output_size[3]);
    else if(num_of_dims == 3)
       sprintf(filename, "output_%d_%dx%dx%d.tensor",num,output_size[0],output_size[1],output_size[2]);
    else if(num_of_dims == 2)
       sprintf(filename, "output_%d_%dx%d.tensor",num,output_size[0],output_size[1]);
    else if(num_of_dims == 1)
       sprintf(filename, "output_%d_%d.tensor",num,output_size[0]);

    fp = fopen(filename, "wb");
    if(fp == NULL)
    {
       printf("open file fail: %s num_of_dims %d \r\n",filename,num_of_dims);
       return;
    }
    outBuf = (vx_float32 *) malloc(count* sizeof(vx_float32));
    if(outBuf == NULL)
    {
        printf("Can't malloc space \n");
    }
    if(data_type == VX_TYPE_INT8)
    {
        vx_int8 *ptr_int8 = (vx_int8 *)buffer;
        for(i = 0; i < count; i++)
        {
            outBuf[i] = Int8toFp32(ptr_int8[i], fix_pos);
            fprintf(fp,"%f\r\n",outBuf[i]);
        }
    }
    else if(data_type == VX_TYPE_UINT8)
    {
        vx_uint8 *ptr_uint8 = (vx_uint8 *)buffer;
        for(i = 0; i < count; i++)
        {
            outBuf[i] = Uint8toFp32(ptr_uint8[i], zero_point, scale);
            fprintf(fp,"%f\r\n",outBuf[i]);
        }
    }
    else if(data_type == VX_TYPE_INT16)
    {
        vx_int16 *ptr_int16 = (vx_int16 *)buffer;
        for(i = 0; i < count; i++)
        {
            outBuf[i] = Int16toFp32(ptr_int16[i], fix_pos);
            fprintf(fp,"%f\r\n",outBuf[i]);
        }
    }
    else if(data_type == VX_TYPE_FLOAT16)
    {
        vx_int16 *ptr_fp16 = (vx_int16 *)buffer;
        for(i = 0; i < count; i++)
        {
            outBuf[i] = Fp16toFp32(ptr_fp16[i]);
            fprintf(fp,"%f\r\n",outBuf[i]);
        }
    }
    else
    {
        printf("Error output tensor format \n");
        fclose(fp);
        return ;
    }
    fclose(fp);
    return outBuf;
#if 0
    if(size == 1)
    {
        if (!getTop((vx_float32*)outBuf, fMaxProb, MaxClass, count, 5))
        {
            printf("Fail to show result.\n");
        }

        printf(" --- Top5 ---\n");

        for (i=0; i<5; i++)
        {
            printf("%3d: %8.6f\n", MaxClass[i], (float)fMaxProb[i]);
        }
    }
    if(outBuf != NULL)
    {
        free(outBuf);
        outBuf = NULL;
    }
#endif
}

static FILE *log_file;

int nnlog_start(char *name)
{
    log_file = fopen(name, "w");
    return 0;
}

void nnlog_end()
{
    if (log_file) {
        fclose(log_file);
        log_file = NULL;
    }
}

void nnlog(char *fmt, ...)
{
   va_list arg_ptr;

   va_start(arg_ptr, fmt);

   if (log_file) {

       vfprintf(log_file, fmt, arg_ptr);
   }

   va_end(arg_ptr);
}


static int trace_enabled = vx_true_e;
static char *scope = "";

void set_scope(char *id)
{
    scope = id;
}

void enable_trace(int enabled)
{
    trace_enabled = enabled;
}

void dump_buffer(void* buffer, int count, int cols, int indent,
        vx_enum data_type)
{
    int i;
    static char prefix[6];

    if (indent > 5) {
        indent = 5;
    }

    memset(prefix, ' ', indent);
    prefix[indent] = 0;

    if (data_type == VX_TYPE_FLOAT32) {
        float *fp = (float*)buffer;

        for (i = 0; i < count; i++) {
            nnlog("  %2.8e", fp[i]);
            if ((i % cols) == cols - 1 && i != count - 1) {
                nnlog("\n%s", prefix);
            }
        }
    } else if (data_type == VX_TYPE_FLOAT16) {
        vx_uint16 *fp = (vx_uint16*)buffer;

        for (i = 0; i < count; i++) {
            nnlog("  %2.8e", Fp16toFp32(fp[i]));
            if ((i % cols) == cols - 1 && i != count - 1) {
                nnlog("\n%s", prefix);
            }
        }
    } else {
        nnlog("not supported format\n");
    }
}

int transpose(void* src, int num_of_dims, vx_uint32 sizes[], vx_uint32 maps[],
        int unit_size, void* dest)
{
    int input_strides[6];
    int output_sizes[6];
    int dest_idx[6];
    int size;
    char *sp, *dp;
    int i, j;

    size = 1;
    for (i = 0; i < num_of_dims; i++) {
        size *= sizes[i];
        output_sizes[i] = sizes[maps[i]];
    }

    input_strides[0] = unit_size;
    for (i = 1; i < num_of_dims; i++) {
        input_strides[i] = input_strides[i - 1] * sizes[i - 1];
    }

    for (i = 0; i < num_of_dims; i++) {
        dest_idx[i] = 0;
    }


    sp = (char*)src;
    dp = (char*)dest;
    for (i = 0; i < size; i++) {
        memcpy(dp, sp, unit_size);
        dp += unit_size;

        for (j = 0; j < num_of_dims; j++) {
            if (dest_idx[j] < output_sizes[j] - 1) {
                dest_idx[j]++;
                break;
            }
            dest_idx[j] = 0;
        }

        sp = (char*)src;
        for (j = 0; j < num_of_dims; j++) {
            sp += dest_idx[j] * input_strides[maps[j]];
        }
    }

    return 0;
}

void dump_tensor(vx_context context, vx_tensor tensor, char* id, vx_bool nhwc)
{
    vx_uint32                   num_of_dims;
    vx_enum                     data_format;
    vx_uint8                    fix_point_pos;
    void*                       buffer = NULL;
    void*                       buffer2 = NULL;
    vx_status                   status;
    vx_uint32                   sizes[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_uint32                   maps[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_uint32                   strides[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_uint32                   starts[NN_TENSOR_MAX_DIMENSION_NUMBER];
    char                        presuffix[NN_TENSOR_MAX_DIMENSION_NUMBER + 2];
    vx_tensor_addressing        addrs = NULL;
    int                         size;
    int                         i, j, level;

    if (!trace_enabled) return;

    nnlog("\n%s:%s", scope, id);

    /* process result */
    status = vxQueryTensor(tensor, VX_TENSOR_NUM_OF_DIMS, &num_of_dims, sizeof(num_of_dims));
    _CHECK_STATUS(status, exit);

    status = vxQueryTensor(tensor, VX_TENSOR_DIMS, sizes, sizeof(sizes));
    _CHECK_STATUS(status, exit);

    status = vxQueryTensor(tensor, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));
    _CHECK_STATUS(status, exit);

    status = vxQueryTensor(tensor, VX_TENSOR_FIXED_POINT_POS, &fix_point_pos, sizeof(fix_point_pos));
    _CHECK_STATUS(status, exit);

    strides[0] = vxcGetTypeSize(data_format);
    for (i = 1; i < (int)num_of_dims; i++)
    {
        strides[i] = strides[i-1] * sizes[i-1];
    }

    size = vxcGetTypeSize(data_format);
    for (i = 0; i < (int)num_of_dims; i++)
    {
        size *= sizes[i];
    }
    buffer = malloc(size);
    buffer2 = malloc(size);

    _CHECK_OBJ(buffer, exit);

    addrs = vxCreateTensorAddressing(
                            context,
                            &sizes[0],
                            &strides[0],
                            num_of_dims
                            );
    _CHECK_OBJ(addrs, exit);

    status = vxCopyTensorPatch(
                    tensor,
                    NULL,
                    addrs,
                    buffer,
                    VX_READ_ONLY,
                    0
                    );
    _CHECK_STATUS(status, exit);

    if (nhwc) {
        int t;
        maps[0] = 2;
        maps[1] = 0;
        maps[2] = 1;
        maps[3] = 3;
        transpose(buffer, num_of_dims, sizes, maps, vxcGetTypeSize(data_format), buffer2);
        free(buffer);
        buffer = buffer2;
        buffer2 = NULL;

        switch (num_of_dims) {
        case 2:
            break;
        case 3:
            t = sizes[2];
            sizes[2] = sizes[1];
            sizes[1] = sizes[0];
            sizes[0] = t;
            break;
        }

        strides[0] = vxcGetTypeSize(data_format);
        for (i = 1; i < (int)num_of_dims; i++)
        {
            strides[i] = strides[i-1] * sizes[i-1];
        }
    }

    nnlog("shape(");
    for (i = 0; i < num_of_dims; i++) {
        starts[i] = 0;
        if (i == num_of_dims - 1) {
            nnlog("%d)\n", sizes[num_of_dims - 1 - i]);
        } else {
            nnlog("%d, ", sizes[num_of_dims - 1 - i]);
        }
    }

    for (i = 0, level = num_of_dims - 1; i < size; i += strides[0] * sizes[0]) {
        for (j = level + 1; j < num_of_dims; j++) {
            presuffix[num_of_dims - 1 - j] = ' ';
        }
        for (j = 0; j <= level; j++) {
            presuffix[num_of_dims - 1 - j] = '[';
        }
        presuffix[num_of_dims] = 0;
        level = 0;

        nnlog("%s", presuffix);
        dump_buffer(&((char *)buffer)[i], sizes[0], 4, num_of_dims, data_format);

        while (++starts[level + 1] >= sizes[level + 1]) {
            starts[level + 1] = 0;
            level++;
            if (level == num_of_dims) {
                break;
            }
        }
        for (j = 0; j <= level; j++) {
            presuffix[j] = ']';
        }
        presuffix[j] = '\n';
        presuffix[j + 1] = 0;

        nnlog("%s", presuffix);
    }

    exit:
    /* release resource */
    if (buffer != NULL) {
        free(buffer);
    }

    if (buffer2 != NULL) {
        free(buffer2);
    }

    if(addrs) {
        vxReleaseTensorAddressing(&addrs);
    }
}

void dump_tensor_to_file(vx_context context, vx_tensor tensor, char* id)
{
    nnlog_start(id);
    dump_tensor(context, tensor, id, vx_false_e);
    nnlog_end();
}
int writeBMP( FILE * desFile, unsigned char* inputBuf, unsigned int width, unsigned int height, int cn)
{
    if(cn != 1 && cn != 4)
    {
        printf("only support channel 1 and 4 \n");
        return -1;
    }

    if(cn == 1)
    {
        FileHeader* vFileHeader = NULL;
        InfoHeader* vInfoHeader = NULL;
        unsigned char* palleteData = NULL;
        unsigned char* imageData = NULL;
        unsigned char* bmpBuffer = NULL;


        unsigned int imgSize = width * height;
        unsigned int headerSize = 1024 + sizeof(FileHeader) + sizeof(InfoHeader);
        unsigned int fileSize = headerSize + imgSize;

        unsigned int i, val, length = 1 << 8;

        bmpBuffer = (unsigned char*)malloc(fileSize);
        if(NULL==bmpBuffer)
        {
            printf("invalid buffer\n");
            return -1;
        }
        else
        {
            vFileHeader = (FileHeader*)bmpBuffer;
            vInfoHeader = (InfoHeader*)(bmpBuffer + sizeof(FileHeader));
            palleteData = bmpBuffer + sizeof(FileHeader) + sizeof(InfoHeader);
            imageData = bmpBuffer + headerSize; 
        }

        // assign vFileHeader & vInfoHeader 
        vFileHeader->fileType = 0x4d42;
        vFileHeader->fileSize1 = (unsigned short)((fileSize << 16) >> 16);
        vFileHeader->fileSize2 = (unsigned short)(fileSize >> 16);
        vFileHeader->fileReserved1 = 0;
        vFileHeader->fileReserved2 = 0;
        vFileHeader->fileOffset1 = (unsigned short)((headerSize << 16) >> 16);
        vFileHeader->fileOffset2 = (unsigned short)(headerSize >> 16);

        vInfoHeader->infoSize = sizeof(InfoHeader);
        vInfoHeader->imageWidth = width;
        vInfoHeader->imageHeight = height;
        vInfoHeader->imagePlane = 1;
        vInfoHeader->imageCount = 8;
        vInfoHeader->imageCompression = 0;
        vInfoHeader->imageSize = 0;
        vInfoHeader->hResolution = 0;
        vInfoHeader->vResolution = 0;
        vInfoHeader->clrUsed = 0;
        vInfoHeader->clrImportant = 0;

        for( i = 0; i < length; i++ )
        {
            val = (i * 255/(length - 1)) ^ 0;
            palleteData[0] = (unsigned char)val;
            palleteData[1] = (unsigned char)val;
            palleteData[2] = (unsigned char)val;
            palleteData[3] = (unsigned char)0;
            palleteData += 4;
        }
        // assign image data
        memcpy(imageData, inputBuf, imgSize);

        // write desFile
        if(desFile == NULL)
        {
            if(bmpBuffer != NULL)
            {
                free(bmpBuffer);
                bmpBuffer = NULL;
            }

            printf("desFile is NULL\n");
            return -1;
        }
        else
        {
            fwrite(bmpBuffer, fileSize, 1, desFile);

            if(bmpBuffer != NULL)
            {
                free(bmpBuffer);
                bmpBuffer = NULL;
            }

        }
    }
    else if(cn == 4)
    {
        FileHeader* vFileHeader = NULL;
        InfoHeader* vInfoHeader = NULL;
        unsigned char* imageData = NULL;
        unsigned char* bmpBuffer = NULL;

        unsigned int imgSize = width * height;
        unsigned int fileSize = sizeof(FileHeader) + sizeof(InfoHeader) + imgSize * 4;

        bmpBuffer = (unsigned char*)malloc(fileSize);
        if(bmpBuffer == NULL)
        {
            printf("malloc bmpBuffer failed\n");
            return -1;
        }
        else
        {
            vFileHeader = (FileHeader*)bmpBuffer;
            vInfoHeader = (InfoHeader*)(bmpBuffer + sizeof(FileHeader));
            imageData = bmpBuffer + sizeof(FileHeader) + sizeof(InfoHeader); 
        }

        // assign vFileHeader & vInfoHeader 
        vFileHeader->fileType = 0x4d42;
        vFileHeader->fileSize1 = (unsigned short)((fileSize << 16) >> 16);
        vFileHeader->fileSize2 = (unsigned short)(fileSize >> 16);
        vFileHeader->fileReserved1 = 0;
        vFileHeader->fileReserved2 = 0;
        vFileHeader->fileOffset1 = (unsigned short)(((sizeof(FileHeader) + sizeof(InfoHeader)) << 16) >> 16);
        vFileHeader->fileOffset2 = (unsigned short)((sizeof(FileHeader) + sizeof(InfoHeader)) >> 16);

        vInfoHeader->infoSize = sizeof(InfoHeader);
        vInfoHeader->imageWidth = width;
        vInfoHeader->imageHeight = -((int)height);
        vInfoHeader->imagePlane = 1;
        vInfoHeader->imageCount = 32;
        vInfoHeader->imageCompression = 0;
        vInfoHeader->imageSize = imgSize * 4;
        vInfoHeader->hResolution = 0;
        vInfoHeader->vResolution = 0;
        vInfoHeader->clrUsed = 0;
        vInfoHeader->clrImportant = 0;

        // assign image data
        memcpy(imageData, inputBuf, imgSize * 4);

        // write desFile
        if(desFile == NULL)
        {
            if(bmpBuffer != NULL)
            {
                free(bmpBuffer);
                bmpBuffer = NULL;
            }

            printf("desFile is NULL\n");
            return -1;
        }
        else
        {
            fwrite(bmpBuffer, fileSize, 1, desFile);

            if(bmpBuffer != NULL)
            {
                free(bmpBuffer);
                bmpBuffer = NULL;
            }
        }
    }

    return 0;
}


void* prepareImageDataForDisplay(char *name, vx_uint32 width, vx_uint32 height, vx_uint32 channels)
{
    vx_uint32 i, j, offset;
    vx_uint8 *bmpData;
    vx_uint8 *outputData = NULL;
    FILE * bmpFile;

    bmpFile = fopen(name, "rb");
    if (bmpFile == NULL) return NULL;

    bmpData = (vx_uint8*) malloc(width * height * channels * sizeof(vx_uint8));
    if (bmpData == NULL) return NULL;
    memset(bmpData, 0, sizeof(vx_uint8) * width * height * channels);

    outputData = (vx_uint8*) malloc(width * height * channels * sizeof(vx_uint8));
    if (outputData == NULL) return NULL;
    memset(outputData, 0, sizeof(vx_uint8) * width * height * channels);

    convertJpegToBmpData(bmpFile, bmpData, NULL, NULL);

    fclose(bmpFile);

    for (i = 0; i < channels; i++)
    {
        offset = width * height * (channels - 1 - i);
		//offset = width * height * i;//
        for (j = 0; j < width * height; j++)
        {
            outputData[j + offset] = bmpData[j * channels + i]; // FIXME
        }
    }

    free(bmpData);
    return outputData;
}


int writeBMToFile( char *fileName, unsigned char* inputBuf, unsigned int width, unsigned int height, int channel, int pixelFormat)
{
    FILE *dstFile = NULL;
    unsigned char *pDstBuff = NULL;
	int cn = channel;
    int status = 0;
	int x = 0, y = 0;

    if(channel != 1 && channel != 4 && channel != 3)
    {
        printf("only support channel 1 3 and 4 @ %s(%d)\n", __FUNCTION__, __LINE__);
        return -1;
    }

    dstFile = fopen(fileName, "wb");
    if(dstFile == NULL)
    {
        printf("desFile is NULL @ %s(%d)\n", __FUNCTION__, __LINE__);
        return -1;
    }

    if(channel == 3)
    {
        cn = 4;
        pDstBuff = (unsigned char *)malloc(width * height * 4);
        if(pDstBuff == NULL)
        {
            printf("malloc buffer failed @ %s(%d)\n", __FUNCTION__, __LINE__);
            return -1;
        }
		if(pixelFormat == 0)
		{  // 交织模式 RGBRGB
			for(y = 0; y < height; y ++)
			{
				for (x = 0; x < width; x++)
				{
					int idx = y * width + x;
					pDstBuff[idx * cn + 0] = inputBuf[idx * channel + 0];
					pDstBuff[idx * cn + 1] = inputBuf[idx * channel + 1];
					pDstBuff[idx * cn + 2] = inputBuf[idx * channel + 2];
					pDstBuff[idx * cn + 3] = 0xCD;
				}
			}
		}
		else if(pixelFormat == 1)
		{  // 交织模式 BGRBGR
			for(y = 0; y < height; y ++)
			{
				for (x = 0; x < width; x++)
				{
					int idx = y * width + x;
					pDstBuff[idx * cn + 0] = inputBuf[idx * channel + 2];
					pDstBuff[idx * cn + 1] = inputBuf[idx * channel + 1];
					pDstBuff[idx * cn + 2] = inputBuf[idx * channel + 0];
					pDstBuff[idx * cn + 3] = 0xCD;
				}
			}
		}
		else if(pixelFormat == 2)
		{  // plant模式 R...RG....GB....B
			int pixIdx = 0;
			for(y = 0; y < height; y ++)
			{
				for (x = 0; x < width; x++)
				{
					int idx = y * width + x;
					pDstBuff[idx * cn + 0] = inputBuf[0 * width * height + idx];
					pDstBuff[idx * cn + 1] = inputBuf[1 * width * height + idx];
					pDstBuff[idx * cn + 2] = inputBuf[2 * width * height + idx];
					pDstBuff[idx * cn + 3] = 0xCD;
				}
			}
		}
		else if(pixelFormat == 3)
		{  // plant模式 B...BG....GR....R
			int pixIdx = 0;
			for(y = 0; y < height; y ++)
			{
				for (x = 0; x < width; x++)
				{
					int idx = y * width + x;
					pDstBuff[idx * cn + 0] = inputBuf[2 * width * height + idx];
					pDstBuff[idx * cn + 1] = inputBuf[1 * width * height + idx];
					pDstBuff[idx * cn + 2] = inputBuf[0 * width * height + idx];
					pDstBuff[idx * cn + 3] = 0xCD;
				}
			}
		}
        status = writeBMP(dstFile, pDstBuff, width, height, cn);
    }
    else
    {
        status = writeBMP(dstFile, inputBuf, width, height, cn);
    }

    if(pDstBuff)
    {
        free(pDstBuff);
        pDstBuff = NULL;
    }
    if(dstFile)
        fclose(dstFile);
  
    return status;
}
