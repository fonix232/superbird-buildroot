/*******************************************************************************
 * Name        : vxc_util.h
 * Author      : Your name
 * Copyright   : Your copyright notice
 * Description : Utility header file generated by VivanteIDE
 *******************************************************************************/

#ifdef  __cplusplus
extern "C" {
#endif

#if defined(linux) || defined(__linux) || defined(__linux__)
#define LINUX 1
#else
#if defined(WIN32) && !defined(__MINGW32__)
#define typeof decltype
#endif
#endif

#ifndef NN_TENSOR_MAX_DIMENSION_NUMBER
#define NN_TENSOR_MAX_DIMENSION_NUMBER 4
#endif

#define _CHECK_OBJ(ptr, label) \
    do \
    { \
        if ((ptr) == NULL) \
        { \
            nnlog("NULL pointer@%d\n", __LINE__); \
            goto label; \
        } \
    } while(0)

#define _CHECK_STATUS(status, label) \
    do \
    { \
        if (status != VX_SUCCESS) \
        { \
            nnlog("Failure @%d\n", __LINE__); \
            goto label; \
        } \
    } while(0)

#ifndef ROUND_HALF_UP
#if defined(WIN32) && !defined(__MINGW32__)
vx_int32 rint_c(vx_float32 val);
#endif
#else
#if defined(WIN32) && !defined(__MINGW32__)
vx_float32 roundf(vx_float32 x);
#endif
#endif

vx_uint32 vxcGetTypeSize(vx_enum format);

vx_int8 Fp32toInt8(vx_float32 in, vx_int32 fl);

vx_int16 Fp32toInt16(vx_float32 in, vx_int32 fl);

vx_uint8 Fp32toUint8(vx_float32 in, vx_int32 zero_point, vx_float32 scale);

vx_float32 Int8toFp32(vx_int8 val, vx_int8 fixedPointPos);

vx_float32 Int16toFp32(vx_int16 val, vx_int8 fixedPointPos);

vx_float32 Uint8toFp32(vx_uint8 val, vx_int32 zero_point, vx_float32 scale);

vx_float32 Fp16toFp32(const vx_int16 in);

vx_uint16 Fp32toFp16(vx_float32 in);

int convertJpegToBmpData(FILE * inputFile, unsigned char* bmpData,
        uint32_t *bmpWidth, uint32_t *bmpHeight);

void* prepareTensorData(char* name, vx_uint32 width, vx_uint32 height,
        vx_uint32 channels);

void* prepareImageData(char *name, vx_uint32 width, vx_uint32 height,
        vx_uint32 channels);

void* prepareData(char *name, int n, int format);

vx_bool getTop(vx_float32 *pfProb, vx_float32 *pfMaxProb, vx_uint32 *pMaxClass,
        vx_uint32 outputCount, vx_uint32 topNum);

vx_float32 * showResult(void* buffer, vx_uint32 count,int num, vx_uint32 num_of_dims,
        vx_uint32 *output_size, vx_enum data_type, vx_enum quant_format,
        vx_uint8 fix_pos, vx_int32 zero_point, vx_float32 scale, int size);

int nnlog_start(char *name);

void nnlog_end();

void nnlog(char *fmt, ...);

void set_scope(char *id);

void enable_trace(int enabled);

void dump_buffer(void* buffer, int count, int cols, int indent,
        vx_enum data_type);

int transpose(void* src, int num_of_dims, vx_uint32 sizes[], vx_uint32 maps[],
        int unit_size, void* dest);

void dump_tensor(vx_context context, vx_tensor tensor, char* id, vx_bool nhwc);

void dump_tensor_to_file(vx_context context, vx_tensor tensor, char* id);

#ifdef  __cplusplus
}
#endif
