/*******************************************************************************
 * Name        : main.c
 * Author      : Your name
 * Copyright   : Your copyright notice
 * Description : Main source file generated by VivanteIDE
 *******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "VX/vx.h"
#include "VX/vxu.h"
#include "VX/vx_khr_cnn.h"
#include "vxc_util.h"
#include "vxc_nn_inceptionV1.h"

int main(int argc, char* argv[])
{
    char*                       input_name = NULL;
    char*                       data_name = NULL;
    vx_context                  context = NULL;
    vx_graph                    graph = NULL;
    vx_tensor                   input = NULL;
    vx_uint32                   num_of_dims;
    vx_uint32                   image_size[NN_TENSOR_MAX_DIMENSION_NUMBER] = {0, 0, 0, 0};
    vx_uint32                   image_stride_size[NN_TENSOR_MAX_DIMENSION_NUMBER] = {0, 0, 0, 0};
    vx_enum                     data_format;
    vx_enum                     quant_format;
    vx_uint8                    fix_point_pos;
    vx_int32                    zero_point;
    vx_float32                  scale;
    vx_tensor_addressing        inputs_tensor_addressing = NULL;
    vx_tensor_create_params_t   tensor_create_params;
    void*                       input_data_ptr = NULL;
    tensors_info_t              outputs_info;
    vx_tensor                   output = NULL;
    void*                       output_ptr = NULL;
    vx_status                   status;
    vx_bool                     nn_created = vx_false_e;
    vx_uint32                   output_size[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_uint32                   output_stride_size[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_tensor_addressing        output_user_addr = NULL;
    int                         size;
    int                         i,j;

    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    if (argc < 3)
       {
           printf("Usage:%s model_data_file_name image_file_name\n", argv[0]);
           return 1;
    }

    data_name  = argv[1];
    input_name = argv[2];

    context = vxCreateContext();
    _CHECK_OBJ(context, exit);

    graph = vxCreateGraph(context);
    _CHECK_OBJ(graph, exit);

    /* Prepare input tensor */
#if defined(NN_INPUT_TENSOR_TEXT)
    input_data_ptr = prepareData(input_name, NN_INPUT_WIDTH * NN_INPUT_HEIGHT, NN_INPUT_DATA_FORMAT);
#else
    if (strstr(input_name,".tensor"))
        input_data_ptr = prepareTensorData(input_name, NN_INPUT_WIDTH, NN_INPUT_HEIGHT, NN_INPUT_CHANNEL);
    else
        input_data_ptr = prepareImageData(input_name, NN_INPUT_WIDTH, NN_INPUT_HEIGHT, NN_INPUT_CHANNEL);
#endif
    _CHECK_OBJ(input_data_ptr, exit);

    num_of_dims    = NN_INPUT_DIMENSION_NUMBER;
    image_size[0]  = NN_INPUT_WIDTH;
    image_size[1]  = NN_INPUT_HEIGHT;
    image_size[2]  = NN_INPUT_CHANNEL;
    if (num_of_dims > 3) image_size[3]  = 1;
    data_format    = NN_INPUT_DATA_FORMAT;

    tensor_create_params.num_of_dims = num_of_dims;
    tensor_create_params.sizes = (vx_int32 *)image_size;
    tensor_create_params.data_format = data_format;
#if defined(NN_TENSOR_DATA_FORMAT_INT8) || defined(NN_TENSOR_DATA_FORMAT_INT16)
    tensor_create_params.quant_format = NN_INPUT_QUANT_TYPE;
    tensor_create_params.quant_data.dfp.fixed_point_pos = NN_INPUT_FIXED_POINT_POS;
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
    tensor_create_params.quant_format = NN_INPUT_QUANT_TYPE;
    tensor_create_params.quant_data.affine.scale = NN_INPUT_AFFINE_SCALE;
    tensor_create_params.quant_data.affine.zeroPoint = NN_INPUT_AFFINE_ZERO_POINT;
#endif
    input = vxCreateTensor2(context, (const vx_tensor_create_params_t*)&tensor_create_params, sizeof(tensor_create_params));
    _CHECK_OBJ(input, exit);

    image_stride_size[0] = vxcGetTypeSize(data_format);
    for (i = 1; i < NN_INPUT_DIMENSION_NUMBER; i++)
    {
        image_stride_size[i] = image_stride_size[i-1] * image_size[i-1];
    }

    inputs_tensor_addressing       = vxCreateTensorAddressing(context, image_size, image_stride_size, NN_INPUT_DIMENSION_NUMBER);
    _CHECK_OBJ(inputs_tensor_addressing, exit);

//    status = vxCopyTensorPatch(input, NULL, inputs_tensor_addressing, input_data_ptr, VX_WRITE_ONLY, 0);
//    _CHECK_STATUS(status, exit);

    /* Set up the neural network */

    status = vxcCreateNeuralNetwork(graph, data_name, input, &outputs_info);
    _CHECK_STATUS(status, exit);
    nn_created = vx_true_e;

    status = vxVerifyGraph(graph);
    _CHECK_STATUS(status, exit);

for (int m = 0; m < 10; m++)
{
	printf("the pic is %d\n", m);
    status = vxCopyTensorPatch(input, NULL, inputs_tensor_addressing, input_data_ptr, VX_WRITE_ONLY, 0);
    _CHECK_STATUS(status, exit);


    status = vxProcessGraph(graph);
    _CHECK_STATUS(status, exit);

#ifdef __linux__
    struct timeval tmsStart, tmsEnd;
    long int msVal2,usVal2;
    gettimeofday( &tmsStart, 0 );
#endif

    status = vxProcessGraph(graph);
    _CHECK_STATUS(status, exit);

#ifdef __linux__
    gettimeofday( &tmsEnd, 0 );
    msVal2 = 1000 * (tmsEnd.tv_sec - tmsStart.tv_sec) + (tmsEnd.tv_usec - tmsStart.tv_usec) / 1000;
    usVal2 = 1000000 * (tmsEnd.tv_sec - tmsStart.tv_sec) + (tmsEnd.tv_usec - tmsStart.tv_usec);
    printf("ProcessGraph time %ldms or %ldus\n", msVal2, usVal2);
#endif

    for (j=0; j < outputs_info.size;j++)
    {
        /* process result */
        output = outputs_info.tensors[j];
        status = vxQueryTensor(output, VX_TENSOR_NUM_OF_DIMS, &num_of_dims, sizeof(num_of_dims));
        _CHECK_STATUS(status, exit);

        status = vxQueryTensor(output, VX_TENSOR_DIMS, output_size, sizeof(output_size));
        _CHECK_STATUS(status, exit);

        status = vxQueryTensor(output, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));
        _CHECK_STATUS(status, exit);
        status = vxQueryTensor(output, VX_TENSOR_FIXED_POINT_POS, &fix_point_pos, sizeof(fix_point_pos));
        _CHECK_STATUS(status, exit);
        status = vxQueryTensor(output, VX_TENSOR_QUANT_FORMAT, &quant_format, sizeof(quant_format));
        status = vxQueryTensor(output, VX_TENSOR_ZERO_POINT, &zero_point, sizeof(zero_point));
        status = vxQueryTensor(output, VX_TENSOR_SCALE, &scale, sizeof(scale));

        output_stride_size[0] = vxcGetTypeSize(data_format);
        size = output_stride_size[0] * output_size[0];
        for (i = 1; i < (int)num_of_dims; i++)
        {
            output_stride_size[i] = output_stride_size[i-1] * output_size[i-1];
            size *= output_size[i];
        }
        output_ptr = malloc(size);

        _CHECK_OBJ(output_ptr, exit);

        output_user_addr = vxCreateTensorAddressing(
                context,
                &output_size[0],
                &output_stride_size[0],
                num_of_dims
                );
        _CHECK_OBJ(output_user_addr, exit);

        status = vxCopyTensorPatch(
                output,
                NULL,
                output_user_addr,
                output_ptr,
                VX_READ_ONLY,
                0
                );
        _CHECK_STATUS(status, exit);

        showResult(output_ptr, size / output_stride_size[0],j,num_of_dims,output_size,data_format, quant_format,fix_point_pos, zero_point, scale, outputs_info.size);
        if (output_ptr != NULL)
        {
            free(output_ptr);
            output_ptr = NULL;
        }

        if (output_user_addr)
        {
            vxReleaseTensorAddressing(&output_user_addr);
        }

    }
}

exit:

    /* release resource */
    if (output_ptr != NULL)
    {
        free(output_ptr);
    }

    if (output_user_addr)
    {
        vxReleaseTensorAddressing(&output_user_addr);
    }

    if (nn_created)
    {
        vxcReleaseNeuralNetwork();
    }

    if (input != NULL)
    {
        vxReleaseTensor(&input);
    }

    if (inputs_tensor_addressing)
    {
        vxReleaseTensorAddressing(&inputs_tensor_addressing);
    }

    if (input_data_ptr != NULL)
    {
        free(input_data_ptr);
    }

    if (graph != NULL)
    {
        vxReleaseGraph(&graph);
    }

    if (context != NULL)
    {
        vxReleaseContext(&context);
    }

    return 0;
}
