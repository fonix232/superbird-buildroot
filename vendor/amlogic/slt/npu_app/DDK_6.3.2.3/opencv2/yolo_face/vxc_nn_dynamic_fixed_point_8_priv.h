/*******************************************************************************
 * Name        : vxc_nn_dynamic_fixed_point_8_priv.h
 * Author      : Your name
 * Copyright   : Your copyright notice
 * Description : Neural network private header file generated by VivanteIDE
 *******************************************************************************/
#ifndef VXC_NN_DYNAMIC_FIXED_POINT_8_PRIV_H
#define VXC_NN_DYNAMIC_FIXED_POINT_8_PRIV_H

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <math.h>
#include "VX/vx.h"
#include "VX/vx_khr_cnn.h"

#define NN_TENSOR_MAX_DIMENSION 6

#define NN_DIV_DS_SIZE_ROUNDING(a, b, p) \
    (((p) == VX_CONVOLUTIONAL_NETWORK_DS_SIZE_ROUNDING_CEILING) ? (((a) + (b) - 1) / (b)) : ((a) / (b)))

typedef struct tensor_split_info
{
    vx_tensor      tensor;
    vx_int32       axis;
    vx_uint32      axis_start;
    vx_uint32      axis_end;
    vx_int32       axis2;
    vx_uint32      axis2_start;
    vx_uint32      axis2_end;
} tensor_split_info_t;

/* Standard APIs */
typedef struct tensor_format_info
{
    vx_enum        data_format;
    vx_enum        quant_format;
    union {
        struct {
            vx_int8 fixed_point_pos; /*!< \brief Specifies the fixed point position when the input element type is int16/int8, if 0 calculations are performed in integer math */
        } dfp;

        struct {
            vx_int32        zero_point;  /*!< \brief  A 32 bit integer, in range [0, 255] */
            vx_float32      scale;       /*!< \brief Scale value for the quantized value */
        } affine;
     } quant_data;
} tensor_format_info_t;

typedef struct tensor_info
{
    vx_tensor               tensor;
    tensor_format_info_t    format;
    vx_int32                num_of_dim;
    vx_uint32               extend[NN_TENSOR_MAX_DIMENSION];
    vx_int64                offset;
    vx_int32                size;
    void*                  data;
} tensor_info_t;

typedef struct tensor_data_info
{
    tensor_format_info_t    format;
    vx_int32                num_of_dim;
    vx_uint32               extend[NN_TENSOR_MAX_DIMENSION];
    vx_int64                offset;
    vx_int32                size;
} tensor_data_info_t;
/* Get the size of specified format */
vx_uint32 vxcGetTypeSize(vx_enum format);

/* Load a tensor from the resource file */
vx_tensor vxcLoadTensor(vx_context context, vx_uint32 num_of_dim,
        vx_uint32 width, vx_uint32 height, vx_uint32 ifm, vx_uint32 ofm,
        tensor_format_info_t* tfi, FILE* fp,
        vx_uint32 blob_offset, vx_uint32 blob_size, vx_uint32 blob_uint_size);
vx_tensor vxcLoadTensor2(vx_context context, vx_uint32 num_of_dim,
        vx_uint32 width, vx_uint32 height, vx_uint32 ifm, vx_uint32 ofm,
        tensor_format_info_t* tfi,
        vx_uint32 blob_offset, vx_uint32 blob_size, vx_uint32 blob_uint_size);

/* Create a tensor from the specified data */
vx_tensor vxcCreateTensorFromData(vx_context context, int num_of_dim,
        vx_uint32 extend[], tensor_format_info_t* tfi, void *data);

/* Create a tensor by quant */
vx_tensor vxcCreateTensor(vx_context context, int num_of_dim, void *size, 
		vx_enum data_format, vx_enum quant_format, 
		vx_float32 scale, vx_int32 zeroPoint, vx_int32 fixed_point_pos);

/* Load weights_biases_parameter from the resource file */
vx_weights_biases_parameter vxcLoadWeightsBiasesParameter(vx_context context,
        FILE* fp, vx_uint32 blob_offset, vx_uint32 blob_size);

/* Create a sub-tensor from a specified tensor */
vx_tensor vxcCreateSubtensor(vx_context context, tensor_split_info_t *tsi);

/* Create an output tensor */
vx_tensor vxcCreateOutputTensor(vx_context context, vx_graph graph, vx_uint32 num_of_dim,
        vx_uint32 *size, tensor_format_info_t* tfi,
        tensor_split_info_t *tensor_split_info, vx_bool output_layer);

/* Initialize a network environment */
vx_status vxcNetworkInit(char *data_file_name);

/* Release a network environment */
void vxcNetworkExit(void);

/* Alloc a node_info */
void *vxcAllocNodeInfo(int size);

/* Free the specified node_info */
void vxcFreeNodeInfo(void** node_info);

#ifndef NN_CONV_MAX_GROUP
#define NN_CONV_MAX_GROUP 2
#endif

typedef struct convolution_relu_pooling_info
{
    tensor_split_info_t         tensor_split_info;

    vx_graph                    graph;
    vx_tensor                   input;
    vx_uint32                   kernel_x;
    vx_uint32                   kernel_y;
    vx_uint32                   ofm;
    vx_tensor                   weight;
    tensor_format_info_t        weight_format;
    vx_uint32                   weight_blob_offset;
    vx_uint32                   weight_blob_size;
    vx_tensor                   bias;
    tensor_format_info_t        bias_format;
    vx_uint32                   bias_blob_offset;
    vx_uint32                   bias_blob_size;
    vx_uint32                   stride_x;
    vx_uint32                   stride_y;
    vx_uint32                   padding_x;
    vx_uint32                   padding_x_right;
    vx_uint32                   padding_y;
    vx_uint32                   padding_y_bottom;
    tensor_format_info_t        output_format;
    vx_bool                     has_relu;
    vx_enum                     pool_type;
    vx_uint32                   pool_size_x;
    vx_uint32                   pool_size_y;
    vx_uint32                   pool_stride_x;
    vx_uint32                   pool_stride_y;
    vx_uint32                   pool_padding_x;
    vx_uint32                   pool_padding_y;
    vx_uint32                   dilation_x;
    vx_uint32                   dilation_y;
    vx_uint32                   group;
    vx_enum                     overflow_policy;
    vx_enum                     rounding_policy;
    vx_enum                     down_scale_size_rounding;
    vx_bool                     output_layer;

    vx_scalar                   pad_const;
    vx_tensor                   output;
    vx_tensor                   inputs[NN_CONV_MAX_GROUP];
    vx_tensor                   outputs[NN_CONV_MAX_GROUP];
    vx_weights_biases_parameter weight_bias[NN_CONV_MAX_GROUP];
    vx_node                     node[NN_CONV_MAX_GROUP];
} convolution_relu_pooling_info_t;

/* Create and initialize a ConvolutionReluPooling layer node */
vx_status vxcCreateConvolutionReluPoolingLayer(void* node_info);

/* Release a Convolution layer */
void vxcReleaseConvolutionReluPoolingLayer(void** node_info);

typedef struct activation_info
{
    tensor_split_info_t         tensor_split_info;

    vx_graph                    graph;
    vx_tensor                   input;
    vx_enum                     func;
    vx_int32                    a;
    vx_int32                    b;
    vx_float32                  c;
    tensor_format_info_t        output_format;
    vx_bool                     output_layer;

    vx_tensor                   output;
    vx_node                     node;
} activation_info_t;

/* Create and initialize an Activation layer node */
vx_status vxcCreateActivationLayer(void* node_info);

/* Release an Activation layer node */
void vxcReleaseActivationLayer(void** node_info);

typedef struct pooling_info
{
    tensor_split_info_t         tensor_split_info;

    vx_graph                    graph;
    vx_tensor                   input;
    vx_enum                     pool_type;
    vx_uint32                   pool_size_x;
    vx_uint32                   pool_size_y;
    vx_uint32                   stride_x;
    vx_uint32                   stride_y;
    vx_uint32                   padding_x;
    vx_uint32                   padding_x_right;
    vx_uint32                   padding_y;
    vx_uint32                   padding_y_bottom;
    vx_enum                     downscale_size_rounding;
    tensor_format_info_t        output_format;
    vx_bool                     output_layer;
    
    vx_tensor                   output;
    vx_node                     node;
} pooling_info_t;

/* Create and initialize a Pooling layer node */
vx_status vxcCreatePoolingLayer(void* node_info);

/* Release a Pooling layer node */
void vxcReleasePoolingLayer(void** node_info);

typedef struct reorg_info
{
    tensor_split_info_t         tensor_split_info;

    vx_graph                    graph;
    vx_tensor                   input;
    vx_uint32                   stride;
    tensor_format_info_t        output_format;
    vx_bool                     output_layer;

    vx_tensor                   output;
    vx_node                     node;
} reorg_info_t;

/* Create and initialize a Reorg node */
vx_status vxcCreateReorgLayer(void* node_info);

/* Release a Reorg layer node */
void vxcReleaseReorgLayer(void** node_info);

typedef struct tensor_concat_info
{
    tensor_split_info_t         tensor_split_info;

    vx_graph                    graph;
    vx_tensor                   *input;
    vx_int32                    number;
    vx_int32                    dimension;
    tensor_format_info_t        output_format;
    vx_bool                     output_layer;

    vx_tensor                   output;
    vx_node                     node;
} tensor_concat_info_t;


/* Create and initialize a ConcatN node */
vx_status vxcCreateConcatNNode(void* node_info);

/* Release a ConcatN node */
void vxcReleaseConcatNNode(void** node_info);

#endif //VXC_NN_DYNAMIC_FIXED_POINT_8_PRIV_H

#ifdef __cplusplus
}
#endif
