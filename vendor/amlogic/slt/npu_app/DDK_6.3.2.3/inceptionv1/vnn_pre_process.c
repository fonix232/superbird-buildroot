/****************************************************************************
*   Generated by ACUITY 3.12.0
*   Match ovxlib 1.0.9
*
*   Neural Network appliction pre-process source file
****************************************************************************/
/*-------------------------------------------
                Includes
-------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "jpeglib.h"

#include "vsi_nn_pub.h"

#include "vnn_global.h"
#include "vnn_pre_process.h"

#define _BASETSD_H
/*-------------------------------------------
                  Functions
-------------------------------------------*/

static vsi_enum vnn_GetFileType(const char *file_name)
{
    vsi_enum type = 0;
    char *ptr;
    char suffix = '.';
    uint32_t pos,n;

    char buff[32] = {0};

    ptr = strrchr(file_name, suffix);
    pos = ptr - file_name;

    n = strlen(file_name) - (pos + 1);
    strncpy(buff, file_name+(pos+1), n);

    if(strcmp(buff, "jpg") == 0
        || strcmp(buff, "jpeg") == 0
        || strcmp(buff, "JPG") == 0
        || strcmp(buff, "JPEG") == 0 )
    {
        type = NN_FILE_JPG;
    }
    else if(strcmp(buff, "tensor") == 0
        || strcmp(buff, "txt") == 0)
    {
        type = NN_FILE_TENSOR;
    }
    else if(strcmp(buff, "qtensor") == 0)
    {
        type = NN_FILE_QTENSOR;
    }
    else
    {
        type = NN_FILE_NONE;
    }

    return type;
}

static int vnn_ConvertJpegToBmpData
    (
    FILE * inputFile,
    unsigned char* bmpData,
    uint32_t bmpWidth,
    uint32_t bmpHeight,
    uint32_t channel
    )
{
    struct jpeg_decompress_struct cinfo;
    struct jpeg_error_mgr jerr;
    JSAMPARRAY buffer;
    unsigned char *point = NULL;
    unsigned long width, height;
    unsigned short depth = 0;

    cinfo.err = jpeg_std_error(&jerr);
    jpeg_create_decompress(&cinfo);
    jpeg_stdio_src(&cinfo,inputFile);
    jpeg_read_header(&cinfo,TRUE);

    cinfo.dct_method = JDCT_IFAST;

    if (bmpData == NULL)
    {
        return VSI_FAILURE;
    }
    else
    {
        jpeg_start_decompress(&cinfo);

        width  = cinfo.output_width;
        height = cinfo.output_height;
        depth  = cinfo.output_components;
        if(width != bmpWidth || height != bmpHeight || depth != channel)
        {
           printf("wrong jpg file , the jpg file size should be %dx%dx%d\n",bmpWidth,bmpHeight,channel);
           return VSI_FAILURE;
        }


        buffer = (*cinfo.mem->alloc_sarray)
            ((j_common_ptr)&cinfo, JPOOL_IMAGE, width*depth, 1);

        point = bmpData;

        while (cinfo.output_scanline < height)
        {
            jpeg_read_scanlines(&cinfo, buffer, 1);
            memcpy(point, *buffer, width * depth);
            point += width * depth;
        }

        jpeg_finish_decompress(&cinfo);
    }

    jpeg_destroy_decompress(&cinfo);

    return VSI_SUCCESS;
}

static uint8_t *vnn_ImagedataToDtype
    (
    vsi_nn_tensor_t *tensor,
    uint8_t *data,
    float *mean_value,
    uint32_t width,
    uint32_t height,
    uint32_t channel
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t   i, j, sz, offset, stride;
    uint8_t *Dbuffer = NULL;

    sz = width * height * channel;
    stride = vsi_nn_TypeGetBytes( tensor->attr.dtype.vx_type );
    Dbuffer = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    _CHECK_PTR(Dbuffer, error);
    memset(Dbuffer, 0, stride * sz * sizeof(uint8_t));

    if(mean_value)
    {
        float mean,scale,val;
        scale = mean_value[3];

        for(i = 0; i < channel; i ++)
        {
            mean = mean_value[i];
            offset = width * height * i;
            for(j = 0; j < width * height; j ++)
            {
                val = ((float)data[offset + j] - mean) / scale;
                status = vsi_nn_Float32ToDtype(val, &Dbuffer[stride * (offset + j)], &tensor->attr.dtype);
                _CHECK_STATUS(status, error);
            }
        }
    }
    else
    {
        for(i = 0; i < sz; i ++)
        {
            status = vsi_nn_Float32ToDtype((float)data[i], &Dbuffer[stride * i], &tensor->attr.dtype);
            _CHECK_STATUS(status, error);
        }
    }

    return Dbuffer;
error:
    if(Dbuffer)free(Dbuffer);
    return NULL;
}

/*
    Transpose the RGB888 data for driver
    RGBRGBRGB --> reorder[2 1 0]: BBBGGGRRR --- caffe
    RGBRGBRGB --> reorder[0 1 2]: RRRGGGBBB --- tensorflow
*/
static void vnn_ImagedataTranspose
    (
    uint8_t *bmp_data,
    uint32_t *reorder,
    uint32_t width,
    uint32_t height,
    uint32_t channels
    )
{
    uint32_t   i, j, offset, sz, order;
    uint8_t *data;

    sz = width * height * channels;
    data = (uint8_t *)malloc(sz * sizeof(uint8_t));
    if(data == NULL) return ;
    memset(data, 0, sizeof(uint8_t) * sz);

    for(i = 0; i < channels; i ++)
    {
        if(reorder && channels > 1)
        {
            order = reorder[i];
        }
        else
        {
            order = i;
        }

        offset = width * height * i;

        for(j = 0; j < width * height; j ++)
        {
            data[j + offset] = bmp_data[j * channels + order];
        }
    }

    memcpy(bmp_data, data, sz * sizeof(uint8_t));
    if(data)free(data);
}

/*
    jpg file --> BMP data(dataformat: RGBRGBRGB...)
*/
static uint8_t *vnn_ReadJpegImage
    (
    const char *name,
    uint32_t width,
    uint32_t height,
    uint32_t channels
    )
{
    uint8_t   *bmpData;
    uint32_t   sz;
    FILE *bmpFile;
    int status;

    bmpData = NULL;
    bmpFile = NULL;
    sz = width * height * channels;

    bmpFile = fopen( name, "rb" );
    _CHECK_PTR(bmpFile, final);

    bmpData = (uint8_t *)malloc( sz * sizeof( uint8_t ) );
    _CHECK_PTR(bmpData, final);
    memset(bmpData, 0, sizeof( uint8_t ) * sz);

    status = vnn_ConvertJpegToBmpData( bmpFile, bmpData, width, height, channels);
    if(status == VSI_FAILURE)
    {
        free(bmpData);
        return NULL;
    }

final:
    if(bmpFile)fclose(bmpFile);
    return bmpData;
}

static vx_dtype *vnn_ReadQTensorImage
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    uint32_t i = 0;
    float fval = 0.0;
    vx_dtype *tensorData;
    uint32_t sz = 1;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    _CHECK_PTR(tensorFile, error);

    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    tensorData = (vx_dtype *)malloc(sz * sizeof(vx_dtype));
    _CHECK_PTR(tensorData, error);
    memset(tensorData, 0, sz * sizeof(vx_dtype));

    for(i = 0; i < sz; i++)
    {
        if(fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail.\n");
            printf("Please check file lines or if the file contains illegal characters\n");
            goto error;
        }
        tensorData[i] = (vx_dtype)fval;
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

static uint8_t *vnn_ReadTensorImage
    (
    vsi_nn_tensor_t *tensor,
    const char *name
    )
{
    vsi_status status = VSI_FAILURE;
    uint32_t i = 0;
    float fval = 0.0;
    uint8_t *tensorData;
    uint32_t sz = 1;
    uint32_t stride = 1;
    FILE *tensorFile;

    tensorData = NULL;
    tensorFile = fopen(name, "rb");
    _CHECK_PTR(tensorFile, error);

    for(i = 0; i < tensor->attr.dim_num; i++)
    {
        sz *= tensor->attr.size[i];
    }

    stride = vsi_nn_TypeGetBytes(tensor->attr.dtype.vx_type);
    tensorData = (uint8_t *)malloc(stride * sz * sizeof(uint8_t));
    _CHECK_PTR(tensorData, error);
    memset(tensorData, 0, stride * sz * sizeof(uint8_t));

    for(i = 0; i < sz; i++)
    {
        if(fscanf( tensorFile, "%f ", &fval ) != 1)
        {
            printf("Read tensor file fail.\n");
            printf("Please check file lines or if the file contains illegal characters\n");
            goto error;
        }
        status = vsi_nn_Float32ToDtype(fval, &tensorData[stride * i], &tensor->attr.dtype);
        _CHECK_STATUS(status, error);
    }

    if(tensorFile)fclose(tensorFile);
    return tensorData;
error:
    if(tensorFile)fclose(tensorFile);
    return NULL;
}

vsi_status vnn_PreProcessInceptionv1
    (
    vsi_nn_graph_t *graph,
    const char *image_name
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_enum fileType;
    vsi_nn_tensor_t *tensor;
    uint8_t *data = NULL;
    uint8_t *bmpData = NULL;
    float mean_value[4] = {128.0,128.0,128.0,128.0};
    uint32_t reorder[3] = {0,1,2};

    tensor = vsi_nn_GetTensor( graph, graph->input.tensors[0] );
    fileType = vnn_GetFileType(image_name);
    if(fileType == NN_FILE_JPG)
    {
        uint32_t width     = tensor->attr.size[0];
        uint32_t height    = tensor->attr.size[1];
        uint32_t channel   = tensor->attr.size[2];

        bmpData = vnn_ReadJpegImage(image_name, width, height, channel);
        _CHECK_PTR(bmpData, final);

        /* image data transpose */
        vnn_ImagedataTranspose(bmpData, reorder, width, height, channel);

        /* handle mean-value and convert data to Dtype */
        data = vnn_ImagedataToDtype(tensor, bmpData, mean_value, width, height, channel);
        _CHECK_PTR(data, final);
    }
    else if(fileType == NN_FILE_TENSOR)
    {
        data = vnn_ReadTensorImage(tensor, image_name);
        _CHECK_PTR(data, final);
    }
    else if(fileType == NN_FILE_QTENSOR)
    {
        data = (uint8_t *)vnn_ReadQTensorImage(tensor, image_name);
        _CHECK_PTR(data, final);
    }
    else
    {
        printf("This Neural Network Only support tensor file or JPG image file\n");
        status = VSI_FAILURE;
        _CHECK_STATUS(status, final);
    }

    /* Copy the Pre-processed data to input tensor */
    status = vsi_nn_CopyDataToTensor(graph, tensor, data);
    _CHECK_STATUS(status, final);

    /* Save the image data to txt */
    if(fileType == NN_FILE_QTENSOR)
    {
        vsi_nn_SaveTensorToText( graph, tensor, "input.txt", NULL );
    }
    else
    {
        vsi_nn_SaveTensorToTextByFp32( graph, tensor, "input.txt", NULL );
    }

final:
    if(bmpData)free(bmpData);
    if(data)free(data);
    return status;
}

static uint8_t *buffer_img = NULL;

void ReleaseBufferImg()
{
    if (buffer_img) free(buffer_img);
}

vsi_bool GetEnvForImageProcess()
{
    int32_t use_img_process;
    char *use_img_process_s;
    use_img_process = 0; /* default is 0 */
    use_img_process_s = getenv("VSI_USE_IMAGE_PROCESS");
    if(use_img_process_s)
    {
        use_img_process = atoi(use_img_process_s);
    }
    if (use_img_process)
    {
        return TRUE;
    }
    return FALSE;
}

static void prepare_imageprocess_params
    (
    vsi_nn_imageprocess_param *imageprocess,
    int32_t *crop_start,
    int32_t *crop_length,
    int32_t *resize_length,
    float *mean_value,
    uint32_t *reorder
    )
{
    imageprocess->crop.enable = vx_true_e;
    imageprocess->crop.dim_num = 4;
    imageprocess->crop.start = crop_start;
    imageprocess->crop.length = crop_length;
    if (mean_value)
    {
        imageprocess->mean.type = VSI_NN_IMAGEPROCESS_MEAN_CHANNEL;
        imageprocess->mean.scale = 1.0 / mean_value[3];
        imageprocess->mean.mean_value_size = 3;
        imageprocess->mean.mean_value = mean_value;
    }
    else
    {
        imageprocess->mean.type = VSI_NN_IMAGEPROCESS_MEAN_NONE;
    }
    imageprocess->resize.type = VSI_NN_IMAGEPROCESS_RESIZE_BILINEAR;
    imageprocess->resize.dim_num = 2;
    imageprocess->resize.length = resize_length;
    imageprocess->reverse_channel = vx_false_e;
    if (reorder)
    {
        if (reorder[0] == 0 && reorder[1] == 1 && reorder[2] == 2)
        {
            imageprocess->reverse_channel = vx_true_e;
        }
    }
}

/*
    image process pipeline:
    1.crop
    2.resize
    3.(val-mean)*scale
    4.RGBRGBRGB ---> BBBGGGRRR
    5.revert channel: BBBGGGRRR ---> RRRGGGBBB
*/
vsi_status vnn_PreProcessInceptionv1_ImageProcess
    (
    vsi_nn_graph_t *graph,
    const char *image_name
    )
{
    vsi_status status = VSI_FAILURE;
    vsi_enum fileType;
    vsi_nn_tensor_t *tensor;
    uint8_t *data = NULL;
    float mean_value[4] = {128.0,128.0,128.0,128.0};
    uint32_t reorder[3] = {0,1,2};

    tensor = vsi_nn_GetTensor( graph, graph->input.tensors[0] );
    fileType = vnn_GetFileType(image_name);
    if(fileType == NN_FILE_JPG)
    {
        vsi_nn_tensor_attr_t attr;
        vsi_nn_imageprocess_param imageprocess;

        /* src image size */
        attr.size[0] = tensor->attr.size[0];
        attr.size[1] = tensor->attr.size[1];
        attr.size[2] = 3;
        attr.size[3] = 1;
        attr.dim_num = 4;

        {
            int32_t crop_start[] = {0, 0, 0, 0};
            int32_t crop_length[] = {attr.size[0], attr.size[1], 3, 1};
            int32_t resize_length[] = {tensor->attr.size[0], tensor->attr.size[1]};

            prepare_imageprocess_params(&imageprocess, crop_start, crop_length,
                resize_length, mean_value, reorder);
        }

        buffer_img = vnn_ReadJpegImage(image_name, attr.size[0], attr.size[1], attr.size[2]);
        status = vsi_nn_op_imageprocess_single_node(graph, &attr, &imageprocess, buffer_img, tensor);
    }
    else
    {
        printf("vnn_PreProcessLenet_ImageProcess Only support JPG image file\n");
        status = VSI_FAILURE;
        _CHECK_STATUS(status, final);
    }

final:
    if(data)free(data);
    return status;
}
