/*******************************************************************************
 * Name        : main.c
 * Author      : Your name
 * Copyright   : Your copyright notice
 * Description : Main source file generated by VivanteIDE
 *******************************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <opencv2/objdetect/objdetect.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <unistd.h>
#include <iostream>
#include <fstream>
#include <dirent.h>
#include <queue>
#include <fcntl.h>
#include <linux/fb.h>
#include <linux/kd.h>/*新添加的，用于进行图形模式时ioctl使用*/
#include <sys/mman.h>
#include <sys/ioctl.h>
#include <sys/stat.h>
#include <pthread.h>
#include "VX/vx.h"
#include "VX/vxu.h"
#include "VX/vx_khr_cnn.h"
#include "vxc_util.h"
#include "vxc_nn_dynamic_fixed_point_8.h"
#include "post_process.h"
#include "vx_utility.h"

extern "C" { void *camera_thread_func(void *arg); }
extern unsigned char *displaybuf;

using namespace std;
using namespace cv;
const char *xcmd="echo 1080p60hz > /sys/class/display/mode;\
fbset -fb /dev/fb0 -g 1920 1080 1920 2160 24;\
echo 1 > /sys/class/graphics/fb0/freescale_mode;\
echo 0 0 1919 1079 >  /sys/class/graphics/fb0/window_axis;\
echo 0 0 1919 1079 > /sys/class/graphics/fb0/free_scale_axis;\
echo 0x10001 > /sys/class/graphics/fb0/free_scale;\
echo 0 > /sys/class/graphics/fb0/blank;";
static int fbfd = 0;
static struct fb_var_screeninfo vinfo;
static struct fb_fix_screeninfo finfo;
static long int screensize = 0;
char *fbp;
int opencv_ok = 0;

int main(int argc, char* argv[])
{
    char*                       input_name = NULL;
    //char*                       data_name = NULL;
    vx_context                  context = NULL;
    vx_graph                    graph = NULL;
    vx_tensor                   input = NULL;
    vx_uint32                   num_of_dims;
    vx_uint32                   image_size[NN_TENSOR_MAX_DIMENSION_NUMBER] = {0, 0, 0, 0};
    vx_uint32                   image_stride_size[NN_TENSOR_MAX_DIMENSION_NUMBER] = {0, 0, 0, 0};
    vx_enum                     data_format;
    vx_enum                     quant_format;
    vx_uint8                    fix_point_pos;
    vx_int32                    zero_point;
    vx_float32                  scale;
    vx_tensor_addressing        inputs_tensor_addressing = NULL;
    vx_tensor_create_params_t   tensor_create_params;
    void*                       input_data_ptr = NULL;
    tensors_info_t              outputs_info;
    vx_tensor                   output = NULL;
    void*                       output_ptr = NULL;
    vx_status                   status;
    vx_bool                     nn_created = vx_false_e;
    vx_uint32                   output_size[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_uint32                   output_stride_size[NN_TENSOR_MAX_DIMENSION_NUMBER];
    vx_tensor_addressing        output_user_addr = NULL;
    int                         size;
    int                         i,j;
	int width = 700;
	int height =  497;
	unsigned char *orgPixel = NULL;
    vx_float32 * outBuf = NULL;
    char * data_name  = "dynamic_fixed_point-8.export.data";
	
	
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);
    
    //if (argc < 3)
     //  {
     //      printf("Usage:%s model_data_file_name image_file_name\n", argv[0]);
     //      return 1;
    //}

    //data_name  = argv[1];
    input_name = argv[1];
    
    context = vxCreateContext();
    _CHECK_OBJ(context, exit);

    graph = vxCreateGraph(context);
    _CHECK_OBJ(graph, exit);
    /* Prepare input tensor */
	
#if defined(NN_INPUT_TENSOR_TEXT)
    input_data_ptr = prepareData(input_name, NN_INPUT_WIDTH * NN_INPUT_HEIGHT, NN_INPUT_DATA_FORMAT);
#else
    if(strstr(input_name,".tensor"))
        input_data_ptr = prepareTensorData(input_name, NN_INPUT_WIDTH, NN_INPUT_HEIGHT, NN_INPUT_CHANNEL);
    else
        input_data_ptr = prepareImageData(input_name, NN_INPUT_WIDTH, NN_INPUT_HEIGHT, NN_INPUT_CHANNEL);
#endif

    _CHECK_OBJ(input_data_ptr, exit);

    num_of_dims    = NN_INPUT_DIMENSION_NUMBER;
    image_size[0]  = NN_INPUT_WIDTH;
    image_size[1]  = NN_INPUT_HEIGHT;
    image_size[2]  = NN_INPUT_CHANNEL;
    if (num_of_dims > 3) image_size[3]  = 1;
    data_format    = NN_INPUT_DATA_FORMAT;
    
    tensor_create_params.num_of_dims = num_of_dims;
    tensor_create_params.sizes = (vx_int32 *)image_size;
    tensor_create_params.data_format = data_format;
#if defined(NN_TENSOR_DATA_FORMAT_INT8) || defined(NN_TENSOR_DATA_FORMAT_INT16)
    tensor_create_params.quant_format = NN_INPUT_QUANT_TYPE;
    tensor_create_params.quant_data.dfp.fixed_point_pos = NN_INPUT_FIXED_POINT_POS;
#elif defined(NN_TENSOR_DATA_FORMAT_UINT8)
    tensor_create_params.quant_format = NN_INPUT_QUANT_TYPE;
    tensor_create_params.quant_data.affine.scale = NN_INPUT_AFFINE_SCALE;
    tensor_create_params.quant_data.affine.zeroPoint = NN_INPUT_AFFINE_ZERO_POINT;
#endif
    input = vxCreateTensor2(context, (const vx_tensor_create_params_t*)&tensor_create_params, sizeof(tensor_create_params));
    _CHECK_OBJ(input, exit);
    
    image_stride_size[0] = vxcGetTypeSize(data_format);
    for (i = 1; i < NN_INPUT_DIMENSION_NUMBER; i++)
    {
        image_stride_size[i] = image_stride_size[i-1] * image_size[i-1];
    }
    
    inputs_tensor_addressing       = vxCreateTensorAddressing(context, image_size, image_stride_size, NN_INPUT_DIMENSION_NUMBER);
    _CHECK_OBJ(inputs_tensor_addressing, exit);

    status = vxCopyTensorPatch(input, NULL, inputs_tensor_addressing, input_data_ptr, VX_WRITE_ONLY, 0);
    _CHECK_STATUS(status, exit);

    /* Set up the neural network */
    status = vxcCreateNeuralNetwork(graph, data_name, input, &outputs_info);
    _CHECK_STATUS(status, exit);
    nn_created = vx_true_e;

    status = vxVerifyGraph(graph);
    _CHECK_STATUS(status, exit);

    status = vxProcessGraph(graph);
    _CHECK_STATUS(status, exit);

    for (j=0; j < outputs_info.size;j++)
    {
        /* process result */
        output = outputs_info.tensors[j];
        status = vxQueryTensor(output, VX_TENSOR_NUM_OF_DIMS, &num_of_dims, sizeof(num_of_dims));
        _CHECK_STATUS(status, exit);

        status = vxQueryTensor(output, VX_TENSOR_DIMS, output_size, sizeof(output_size));
        _CHECK_STATUS(status, exit);

        status = vxQueryTensor(output, VX_TENSOR_DATA_TYPE, &data_format, sizeof(data_format));
        _CHECK_STATUS(status, exit);
        status = vxQueryTensor(output, VX_TENSOR_FIXED_POINT_POS, &fix_point_pos, sizeof(fix_point_pos));
        _CHECK_STATUS(status, exit);
        status = vxQueryTensor(output, VX_TENSOR_QUANT_FORMAT, &quant_format, sizeof(quant_format));
        status = vxQueryTensor(output, VX_TENSOR_ZERO_POINT, &zero_point, sizeof(zero_point));
        status = vxQueryTensor(output, VX_TENSOR_SCALE, &scale, sizeof(scale));

        output_stride_size[0] = vxcGetTypeSize(data_format);
        size = output_stride_size[0] * output_size[0];
        for (i = 1; i < (int)num_of_dims; i++)
        {
            output_stride_size[i] = output_stride_size[i-1] * output_size[i-1];
            size *= output_size[i];
        }
        output_ptr = malloc(size);

        _CHECK_OBJ(output_ptr, exit);

        output_user_addr = vxCreateTensorAddressing(
                context,
                &output_size[0],
                &output_stride_size[0],
                num_of_dims
                );
        _CHECK_OBJ(output_user_addr, exit);

        status = vxCopyTensorPatch(
                output,
                NULL,
                output_user_addr,
                output_ptr,
                VX_READ_ONLY,
                0
                );
        _CHECK_STATUS(status, exit);

        outBuf=showResult(output_ptr, size / output_stride_size[0],j,num_of_dims,output_size,data_format, quant_format,fix_point_pos, zero_point, scale, outputs_info.size);
	//orgPixel = (unsigned char *)prepareImageDataForDisplay("2.jpg",width,height,3);
    //yolo_v2_post_process(orgPixel,outBuf,width,height,13,13,size/output_stride_size[0], (int *)output_size);

	//writeBMToFile("yolo_face_output.bmp",orgPixel,width, height,3,2);
        if (output_ptr != NULL)
        {
            free(output_ptr);
            output_ptr = NULL;
        }

        if(output_user_addr)
        {
            vxReleaseTensorAddressing(&output_user_addr);
        }

    }

exit:

    /* release resource */
    if (output_ptr != NULL)
    {
        free(output_ptr);
    }

    if(output_user_addr)
    {
        vxReleaseTensorAddressing(&output_user_addr);
    }

    if (nn_created)
    {
        vxcReleaseNeuralNetwork();
    }
    
    if (input != NULL)
    {
        vxReleaseTensor(&input);
    }

    if(inputs_tensor_addressing)
    {
        vxReleaseTensorAddressing(&inputs_tensor_addressing);
    }

    if (input_data_ptr != NULL)
    {
        free(input_data_ptr);
    }

    if (graph != NULL)
    {
        vxReleaseGraph(&graph);
    }

    if (context != NULL)
    {
        vxReleaseContext(&context);
    }
    
    return 0;
}
