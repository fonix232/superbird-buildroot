//----------------------------------------------------------------------------
//   The confidential and proprietary information contained in this file may
//   only be used by a person authorised under and to the extent permitted
//   by a subsisting licensing agreement from ARM Limited or its affiliates.
//
//          (C) COPYRIGHT [2018] Amlogic Limited or its affiliates.
//              ALL RIGHTS RESERVED
//
//   This entire notice must be reproduced on all copies of this file
//   and copies of this file may only be made by a person if such person is
//   permitted to do so under the terms of a subsisting license agreement
//   from ARM Limited or its affiliates.
//----------------------------------------------------------------------------

/*
    Auto White Balance module:
        1. Plankian curve based
        2. Mesh lookup table based
        3. NBP decision tables

    Controls:
        AWB_SMOOTH_FILTER     - Enable smooth filter (fifo depth is FIFO_DEPTH)
        AWB_PRINT_DEBUG        - Enable test mode (with tracing debug information)
        AWB_TEST_DATA       - Runs test data through the system
        AWB_SIM_OLD_MESH    - Change probablities to simulation old awb mesh algorithm

    Default configuration:
        AWB_SMOOTH_FILTER - disable
        AWB_PRINT_DEBUG      - disable
        AWB_TEST_DATA     - disable
        AWB_SIM_OLD_MESH  - disable

    Sensor-depended DATA SECTION:    (TBD: DATA SECTION should be generated by the calibration tool)
        1. light_src
        2. rg_pos
        3. bg_pos
        4. rgbg_weight
        5. rgbg_ls_weight
        6. color_temp_mesh
        7. p_rg_low
        8. p_rg_high
        9. p_lux_low
        10. p_lux_high
        11. color_temp
        12. ct_rg_pos_calc
        13. ct_bg_pos_calc

    Structure of the module:
        1. Controls
        2. DATA SECTION (see $SENSOR_mesh_lookup.h)
        3. Routines
        4. AWB functions (calling order:  awb.scxml)


*/

#include <string.h>

#include "awb_standard_api.h"
#include "awb_acamera_core.h"
#include "awb_acamera_log.h"

#define MAX_AWB_ZONES ( 33 * 33 )

typedef struct _awb_acamera_core_obj_ {
	uint8_t p_high;
	uint8_t p_low;
	uint8_t internal_inited;

	uint32_t rg_avg;
	uint32_t gb_avg;
	uint32_t stable_avg_RG;
	uint32_t stable_avg_BG;
	uint32_t avg_GR;
	uint32_t avg_GB;
	uint16_t rg_coef;
	uint16_t bg_coef;

	int32_t max_temp;
	int32_t min_temp;
	uint16_t max_temp_rg;
	uint16_t max_temp_bg;
	uint16_t min_temp_rg;
	uint16_t min_temp_bg;

	int32_t temperature_detected;
	uint8_t light_source_candidate;

	int32_t awb_warming_A[3];
	int32_t awb_warming_D75[3];
	int32_t awb_warming_D50[3];
	int32_t awb_warming[3];

	uint8_t mvalid[MAX_AWB_ZONES];
	uint8_t cwfzones[MAX_AWB_ZONES];
	uint8_t npcHigh[MAX_AWB_ZONES];
	uint8_t npcLow[MAX_AWB_ZONES];
	uint8_t sky_zones[MAX_AWB_ZONES];
	uint16_t rg_valid[MAX_AWB_ZONES];
	uint16_t bg_valid[MAX_AWB_ZONES];
	int32_t weight_[MAX_AWB_ZONES];
} awb_acamera_core_obj_t;

static awb_acamera_core_obj_t awb_core_objs[FIRMWARE_CONTEXT_NUMBER];

void *awb_acamera_core_init( uint32_t ctx_id )
{
	awb_acamera_core_obj_t *p_awb_core_obj = NULL;

	if ( ctx_id >= FIRMWARE_CONTEXT_NUMBER ) {
		LOG( LOG_CRIT, "Invalid ctx_id: %d, greater than max: %d.", ctx_id, FIRMWARE_CONTEXT_NUMBER - 1 );
		return NULL;
	}

	p_awb_core_obj = &awb_core_objs[ctx_id];
	memset( p_awb_core_obj, 0, sizeof( *p_awb_core_obj ) );

	p_awb_core_obj->stable_avg_RG = D50_DEFAULT;
	p_awb_core_obj->stable_avg_BG = D50_DEFAULT;
	p_awb_core_obj->avg_GR = 128;
	p_awb_core_obj->avg_GB = 128;

	p_awb_core_obj->max_temp = 10000;
	p_awb_core_obj->min_temp = 2100;
	p_awb_core_obj->max_temp_rg = 256;
	p_awb_core_obj->max_temp_bg = 256;
	p_awb_core_obj->min_temp_rg = 256;
	p_awb_core_obj->min_temp_bg = 256;

	p_awb_core_obj->internal_inited = 0;

	return p_awb_core_obj;
}

int32_t awb_acamera_core_deinit( void *awb_ctx )
{
	return 0;
}

int32_t awb_acamera_core_proc( void *awb_ctx, awb_stats_data_t *stats, awb_input_data_t *input, awb_output_data_t *output )
{
	awb_acamera_core_obj_t *p_awb_core_obj = (awb_acamera_core_obj_t *)awb_ctx;
	awb_acamera_input_t *p_acamera_input = (awb_acamera_input_t *)input->acamera_input;
	awb_calibration_data_t *p_cali_data = &( p_acamera_input->cali_data );
	awb_acamera_output_t *p_acamera_output = (awb_acamera_output_t *)output->acamera_output;

	if ( !awb_ctx || !stats || !input || !input->acamera_input
				|| !output || !output->acamera_output ) {
		LOG( LOG_ERR, "Invalid NULL pointer, %p-%p-%p-%p-%p-%p.",
			awb_ctx, stats, input,
			input ? input->acamera_input : NULL,
			output, output ? output->acamera_output : NULL );
		return -1;
	}

	if ( stats->zones_size > MAX_AWB_ZONES ) {
		LOG( LOG_ERR, "Not supported AWB zones, current size: %d, max: %d.",
					stats->zones_size, MAX_AWB_ZONES );
		return -2;
	}

	p_acamera_output->rg_coef = p_awb_core_obj->rg_coef;
	p_acamera_output->bg_coef = p_awb_core_obj->bg_coef;
	p_acamera_output->temperature_detected = p_awb_core_obj->temperature_detected;
	p_acamera_output->p_high = p_awb_core_obj->p_high;
	p_acamera_output->light_source_candidate = p_awb_core_obj->light_source_candidate;
	memcpy( p_acamera_output->awb_warming, p_awb_core_obj->awb_warming, sizeof( p_acamera_output->awb_warming ) );

	return 0;
}
